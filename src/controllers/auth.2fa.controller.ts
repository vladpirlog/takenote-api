import { Request, Response, NextFunction } from 'express'
import createResponse from '../utils/createResponse.util'
import userQuery from '../queries/user.query'
import twoFactorAuth from '../utils/twoFactorAuth.util'
import { IUserSchema } from '../types/User'
import AuthStatus from '../enums/AuthStatus.enum'

/**
 * Controller for generating a qrcode image with the totp secret.
 * Will be displayed and scanned by the user.
 */
const generate2faSecret = async (req: Request, res: Response, next: NextFunction) => {
    try {
        if (!req.session.userID) throw new Error('User not logged in.')
        const user = await userQuery.getById(req.session.userID)
        if (!user || user.twoFactorAuth.active) return createResponse(res, 400)

        const { secret, image } = await twoFactorAuth.generateSecretAndImage(user.email)
        await userQuery.set2faData(req.session.userID, { secret })

        return createResponse(res, 200, 'Image data fetched.', { image })
    } catch (err) { return next(err) }
}

/**
 * Controller for verifying app-generated otp. Used for the login flow and initial 2fa setup.
 */
const verify2faCode = async (req: Request, res: Response, next: NextFunction) => {
    try {
        if (!req.session.userID) throw new Error('User not logged in.')
        const { code, remember } = req.query
        const user = await userQuery.getById(req.session.userID)
        if (!user || !user.twoFactorAuth.secret || block2faVerfication(user, req.session.authenticationStatus)) { // todo
            return createResponse(res, 401)
        }

        if (!isValidOTPOrBackupCode(code as string, user)) return createResponse(res, 403)

        const newNextCheckTime = twoFactorAuth.getNextCheckTime(remember as string | undefined)
        if (user.is2faRequiredOnLogin()) {
            const backupCodeUsed = user.twoFactorAuth.backupCodes?.find(b => b.active && b.id === code)
            const updateData: {
                nextCheck?: IUserSchema['twoFactorAuth']['nextCheck'],
                backupCodes?: IUserSchema['twoFactorAuth']['backupCodes']
            } = {}
            if (newNextCheckTime !== user.twoFactorAuth.nextCheck) updateData.nextCheck = newNextCheckTime

            if (backupCodeUsed) {
                backupCodeUsed.active = false
                updateData.backupCodes = user.twoFactorAuth.backupCodes
            }
            if (newNextCheckTime !== user.twoFactorAuth.nextCheck || backupCodeUsed) {
                await userQuery.set2faData(user.id, updateData)
            }
            return await handle2faOnLogin(req, res, user)
        }

        // executed only on the initial 2fa setup
        const backupCodes = twoFactorAuth.generateBackupCodes()
        await userQuery.set2faData(req.session.userID, {
            active: true, nextCheck: newNextCheckTime, backupCodes
        })
        return createResponse(res, 201, 'Two-factor authentication enabled.', { backupCodes })
    } catch (err) { return next(err) }
}

const isValidOTPOrBackupCode = (
    code: string, user: IUserSchema
) => {
    const isValidOTP = twoFactorAuth.verifyCode(code as string, user.twoFactorAuth.secret as string)
    const isValidBackupCode = user.twoFactorAuth.backupCodes &&
        user.twoFactorAuth.backupCodes.find(b => b.active && b.id === code) !== undefined
    return isValidOTP || isValidBackupCode
}

const handle2faOnLogin = async (
    req: Request,
    res: Response,
    user: IUserSchema
) => {
    req.session.authenticationStatus = AuthStatus.LOGGED_IN
    return createResponse(res, 200, 'Authentication successful.', {
        user: user.getPublicInfo()
    })
}

/**
 * Condition for blocking the otp verification request.
 * Prevents users from trying codes when not needed.
 * @param authStatus the current authentication level of the user
 * @param user object of type IUserSchema
 */
const block2faVerfication = (user: IUserSchema, authStatus: AuthStatus = AuthStatus.NOT_LOGGED_IN) => {
    if (authStatus === AuthStatus.LOGGED_IN) return !user.is2faInitialSetup()
    return !user.is2faRequiredOnLogin()
}

/**
 * Controller for disabling the 2fa flow. Requires a otp generated by the app.
 */
const disable2fa = async (req: Request, res: Response, next: NextFunction) => {
    try {
        if (!req.session.userID) throw new Error('User not logged in.')
        const { code } = req.query

        const user = await userQuery.getById(req.session.userID)
        if (!user || !user.twoFactorAuth.secret || !user.twoFactorAuth.active) {
            return createResponse(res, 401)
        }

        const ok = twoFactorAuth.verifyCode(code as string, user.twoFactorAuth.secret)

        if (!ok) return createResponse(res, 403)

        await userQuery.remove2faData(req.session.userID)
        return createResponse(res, 200)
    } catch (err) { return next(err) }
}

export default { generate2faSecret, verify2faCode, disable2fa }
